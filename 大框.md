# 一.Python base

## (一)什么是面向对象

面向对象三大基本特征:封装/继承/多态

**1.封装:**

1. 分而治之:将一个大的需求分解为许多类,每个类处理一个独立的功能
2. 封装变化:变化的地方独立封装,避免影响其他类
3. 高内聚:每个类完成一个变化点
4. 低耦合:类与类的关联性和依赖度要低,一个类的变化尽可能少影响其他类

**2.继承:**一个代码复用的方式,作用是为了隔离客户端代码与功能的实现,就是抽象变化点用来用与做

**3.多态:**增强程序的扩展性,尽量在不影响原代码的基础上 增加新的功能

**六大基本原则:开闭原则/单一职责/依赖倒置/组合复用/里氏替换/迪米特法则**

**1.开闭原则:**对扩展开放,对修改关闭,增加新功能,不改变原有代码

**2.单一职责:**针对的问题是类与类的耦合性,每次修改这个类代码的原因只能有一个,不能因为其他类的问题修改此类

**3.依赖倒置:**通过把传统的依赖具象代码关系转变成抽象代码方式 就是客户端代码调用的类进项依赖使用抽象的组件 而不是直接依赖父类

**4.里式替换:**进一步要求父类尽可能不要存在态具体的功能,能抽象就抽象,任何的修改都完全依靠子类来补充和修改 也是开闭原则 对父类修改关系 对子类修改开放 也可以是说重写父类的方法

**5.迪米特法则:**又戏称"最少知道法则",说白了就是针对面向对象里的低耦合,它的本意指的就是类与类之间尽可能不要有太多的关联,当一个类需要产生变化时,其他的类尽量做到不产生改动.就是类与类交互时，在满足功能要求的基础上，传递的数据量越少越好。因为这样可能降低耦合度。

**6.组合复用:**就是指组合关系和集成关系都能满足业务要求是,有限使用组合关系

​	泛华/关联/依赖

​	泛华:子类与父类的关系:继承

​	关联:部分与整体的关系,功能的复用,变化影响一个类 就好比在A类中包含B类的成员

​	依赖:合作关系,就好比B类作为A类方法的参数,并不是A的成员 在关联关系的基础上进一步降低了耦合度

## (二)数据类型

数字类型(int/float/bool/complex),字符串类型string,列表类型list,元组类型tuple,字典类型dict,集合类型set

### (1)哪些数据类型可变,哪些数据类型不可变?

可变数据类型有:列表,字典,集合

不可变数据类型有:元组,字符串

### (2)如何区分是否可变

从对象内存地址来说

可变数据类型:在内存地址不变的情况下,值可改变(列表和字典都是可变类型,但是字典中的key必须是不可变类型)

不可变数据类型:内存改变,值也跟着改变,(数字,字符串,布尔类型,元组都是不可变类型)

可以通过id()方法进行内存地址的检查

### (3)list如何去重

**1.利用set的自动去重功能**

将列表转化为集合,在转化为列表,利用集合的自动去重功能,简单快速

缺点是如果用集合无法保证去重后的顺序

**2.直观方法**

先建立一个空列表,通过遍历原来的列表,在利用逻辑关系,not in来去重

**3.可以通过列表中索引(index)的方法保证去重后的顺序不变**

### (4)字典如何排序，1.根据key，2.根据value

```python
# 初始化字典
a = {"b": 5, "c": 2, "a": 4, "d": 1}
# 对字典按键（key）进行排序（默认由小到大）
test_1 = sorted(a.items(), key=lambda x: x[0])
# 输出结果
print(test_1)  
# [('a', 4), ('b', 5), ('c', 2), ('d', 1)]
# 对字典按值（value）进行排序（默认由小到大）
test_2 = sorted(a.items(), key=lambda x: x[1])
# 输出结果
print(test_2)  
# [('d', 1), ('c', 2), ('a', 4), ('b', 5)]
```

sorted(d.items(), key=lambda x: x[1]) 中 d.items() 为待排序的对象；key=lambda x: x[1] 为对前面的对象中的第二维数据（即value）的值进行排序。 key=lambda  变量：变量[维数] 。维数可以按照自己的需要进行设置。

**维数以字符串来表示**

```python
# 将列表中的age由大到小排序
alist = [{'name':'a','age':20},{'name':'b','age':30},{'name':'c','age':25}]
b=sorted(alist,key=lambda x:x['age'],reverse=True)
print(b)
#[{'name': 'b', 'age': 30}, {'name': 'c', 'age': 25}, {'name': 'a', 'age': 20}]
```

### (5)列表和元组的区别

1. 列表可变序列,元组不可以变序列.
2. 元组可以作为字典的键,列表不能
3. 列表可以使用append(),extend(),insert(),remove(),pop()等方法实现添加和修改列表元素,而元组不能
4. 列表可以使用切片访问和修改列表中的元素,元组通过切片只能访问元素,不支持修改
5. 元组比列表的访问和处理速度块,所以只需要对其中的元素进行访问,而不进行修改时,建议使用元组

##  (三)迭代器,生成器

### (1)迭代器,生成器是什么?

1.迭代器是一个更加抽象的概念,任何对象,如果他的类有next方法和iter方法返回自身.对于string,list,dict,tuple等这类容器对象,使用for循环遍历是很方便的.在后台for语句对容器对象调用了iter()函数,iter()是python的内置函数.iter()会返回一个定义了next()方法的迭代器对象,他在容器中逐个访问容器内元素,next()也是python的内置函数在没有后续元素时,next()会排除一个Stoplterration的异常.

2.生成器是创建迭代器的简单而强大的工具,只是在返回数据的时候需要使用yield语句.每次next()被调用时,生成器就会返回他脱离的位置(它记忆语句最后一次执行的位置和所有的数据值)

### (2)他们的区别?

生成器能做到迭代器能做的所有事,而且因为自动创建了 __ iter __ ()和next()方法,生成器显得特别简洁,而且生成器也是高效的,使用生成器表达式取代列表解析可以同时节省内存,除了创建和保持程序状态的自动生成,当生成器终结时,也会自动抛出Stoplterration的异常

## (四)闭包.装饰器

闭包:其实就是在一个函数中嵌套另一个函数的定义。

创建闭包必须满足三点要求:

1. 必须有一个内嵌函数
2. 内嵌函数必须引用外部函数中的变量
3. 外部函数的返回值必须是内嵌函数

**闭包的作用**:包括了外部函数的局部变量，这些局部变量在外部函数返回后也继续存在，并能被内部函数引用。

装饰器:其实是用闭包来实现的。

**装饰器的作用:**在不改变原先的函数值跟调用的方式,添加额外的功能

## (五)推导式

## (六)lamad表达式

# 二.网络编程

## (一)并发.并行.进程.线程.协成基本概念

1.并发:同时处理多个任务,内核在任务间不断的切换达到好像多个任务被同时执行的效果,实际上每个时刻只有一个任务占用内核

2.并行:多个任务利用计算机多核资源在同时执行,此时多个任务间为并行关系

3.进程:是一个动态的过程描述,占有计算机运行资源,有一定的生命周期

4.线程:可以理解为进程的分支任务,也被称为轻量级的进程,可以使用计算机多核资源,是多资源编程方式,是系统内分配内核的最小单位

5.协程:微线程,是为非抢占式多任务产生子程序的计算机主键,协程允许不同入口点子在不同位置暂定或开始 就是说协程可以暂停执行的函数

6.程序:是一个可执行的文件,是静态的占有磁盘.

## (二)(多)进程的几种创建方式
(1)fork创建进程
	pid = os.fork()
(2)multiprocessing创建进程	
	import multiprocessing as mp
	p = Process()
	p.start()
	p.join([timeout])

(3)进程池

## (三)(多)线程的几种创建方式
(1)threading模块创建线程	
	from threading import Thread
	t = Thread()
	t.start()
	t.join([timeout])

(2)自定义线程类

## (四)python多用多进程还是多线程，为什么
	Python下推荐使用多进程！
	1、先了解下GIL是什么？(全局解释器锁)，为了数据安全所做的决定。        
	2、每个CPU在同一时间只能执行一个线程（在单核CPU下的多线程其实都只是并发，不是并行，并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。）
	3.在Python多线程下，每个线程的执行方式：
		1、获取GIL
		2、执行代码直到sleep或者是python虚拟机将其挂起。
		3、释放GIL    
	可见，某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行。                       
	    每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。        
	                             
	那么是不是python的多线程就完全没用了呢？        
	在这里我们进行分类讨论：        
		1、CPU密集型代码(各种循环处理、计数等等)，在这种情况下，由于计算工作多，会触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。        
		2、IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对IO密集型代码比较友好。     
		所以就是CPU密集型的情况下 用进程  IO密集型的情况下用线程
	请注意：多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低.
	python下想要充分利用多核CPU，就用多进程”，原因是什么呢？        
	原因是：每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，所以在python中，多进程的执行效率优于多线程(仅仅针对多核CPU而言)。        
## (五)同步，互斥是什么，并且说明在python中如何体现
	同步 ： 同步是一种协作关系，为完成操作，多进程或者线程间形成一种协调，按照必要的步骤有序执行操作。
	互斥 ： 互斥是一种制约关系，当一个进程或者线程占有资源时会进行加锁处理，此时其他进程线程就无法操作该资源，直到解锁后才能操作。
	死锁:是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。
## (六)如何避免死锁

	通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率。
## (七)谈谈你对http和https的理解

- htttp:超文本传输协议,基于tcp/ip协议的应用层协议,无状态的协议,是客户端和服务端之间数据传输的格式规范,基于tcp的连接方式,80端口
- https:是由ssl+http协议构建的可进行加密传输.身份验证的网络协议,更加安全,443端口

## (八)osi七层模型，说出常用的协议以及位于哪一层

作用:网络通信工作流程标准化

种类复杂,逐渐演化更符合实际情况的四成模型(tcp/ip模型)

	应用层:为用户提供所需要的各种服务(文件传输,数据格式化,代码转换,数据加密)(http,ftp,smtp)	
	传输层:为应用层提供端到端的通信功能,保证了数据包的顺序传送以及数据的完整性(tcp,udp)
	网络层:为数据包选择路由(ip)
	链路层:以二进制数据形式在物理媒体上传输数据(FDDI,PDN,SLIP)


	应用层		HTTP,FTP,dns
	表示层		
	会话层		DNS
	传输层		tcp,udp
	网络层		IP
	数据链路层	
	物理层			
## (九)在浏览器输入url后会发生什么

域名解析 --> 发起3次握手 --> 建立TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求 --> 浏览器解析html代码 --> 并请求html代码中的资源 --> 四次挥手断开tcp连接 --> 浏览器对页面渲染呈现给用户

## (十)tcp和udp的区别，适合在什么场景使用

- 流式套接字是以字节流方式传输数据，数据报套接字以数据报形式传输
- tcp套接字会有粘包，udp套接字有消息边界不会粘包
- tcp套接字保证消息的完整性，udp套接字则不能
- tcp套接字依赖listen accept建立连接才能收发消息，udp套接字则不需要
- tcp套接字使用send，recv收发消息，udp套接字使用sendto，recvfrom

tcp:用途广泛如传输文件,发送接收邮件,远程登录等
upd:聊天室,直播等

## (十一)手写tcp客户端服务端用到的函数

 **(1)服务端:**

- socketfd = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
- socketfd.bind((ip,port))
- socketfd.listen(3)
- connfd,addr = socketfd.accept()
- data = connfd.recv(n)
- connfd.send(b'')
- connfd.close()
- socketfd.close()

**(2)客户端:**

- socketfd = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
- sockfd.bind((ip,port))
- server_addr = (ip,port)	
- sockfd.connect(server_addr)
- sockfd.send(data.encode())
- sockfd.recv
- sockfd.close()

## (十二)简述三次握手和四次挥手的过程，为什么是4次挥手而不是3次挥手

**(1)三次握手(建立连接)**

- 一次握手:客户端通过向服务器端发送消息报文请求连接

- 二次握手:服务器端收到请求后,回复报文确定可以连接

- 三次握手:客户端收到回复,发送请求报文连接建立

  ```
  举个打电话的例子：
  　　A : 你好我是A，你听得到我在说话吗
  　　B : 听到了，我是B，你听到我在说话吗
  　　A : 嗯，听到了
  　　建立连接，开始聊天！
  ```

**(2)四次挥手(断开连接)**

- 一次挥手:主动方发送报文请求断开连接

- 二次挥手:被动方收到请求后,立即回复,表示准别断开

- 三次挥手:被动方准备就绪,再次发送报文表示可以断开

- 四次挥手:主动方收到确定,发送最终报文完成断开

  ```
  三次握手：
  A:“喂，你听得到吗？”A->SYN_SEND
  B:“我听得到呀，你听得到我吗？”应答与请求同时发出 B->SYN_RCVD | A->ESTABLISHED
  A:“我能听到你，今天balabala……”B->ESTABLISHED
  四次挥手：
  A:“喂，我不说了。”A->FIN_WAIT1
  B:“我知道了。等下，上一句还没说完。Balabala…..”B->CLOSE_WAIT | A->FIN_WAIT2
  B:”好了，说完了，我也不说了。”B->LAST_ACK
  A:”我知道了。”A->TIME_WAIT | B->CLOSED
  A等待2MSL,保证B收到了消息,否则重说一次”我知道了”,A->CLOSED
  ```

**(3)为什么是4次挥手而不是3次挥手**

- 当主机A确认发送完数据且知道B已经接受完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给主机B。
- 主机B收到A发送的FIN，表示收到了，就会发送ACK回复。
- **==但这是B可能还在发送数据，没有想要关闭数据口的意思，所以FIN与ACK不是同时发送的，而是等到B数据发送完了，才会发送FIN给主机A。==**
- A收到B发来的FIN，知道B的数据也发送完了，回复ACK， A等待2MSL以后，没有收到B传来的任何消息，知道B已经收到自己的ACK了，A就关闭链接，B也关闭链接了。

## (十三)cookie和session是什么，区别

- Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。IETF RFC 2965 HTTP State Management Mechanism 是通用cookie规范。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies 。
- session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。

|          | Cookie                                               | Session  |
| -------- | ---------------------------------------------------- | -------- |
| 储存位置 | 客户端                                               | 服务器端 |
| 目的     | 跟踪会话，也可以保存用户偏好设置或者保存用户名密码等 | 跟踪会话 |
| 安全性   | 不安全                                               | 安全     |

session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。

Cookie与Session都能够进行会话跟踪，但是完成的原理不太一样。普通状况下二者均能够满足需求，但有时分不能够运用Cookie，有时分不能够运用Session。下面经过比拟阐明二者的特性以及适用的场所。

**1 .存取方式的不同**

Cookie中只能保管ASCII字符串，假如需求存取Unicode字符或者二进制数据，需求先进行编码。Cookie中也不能直接存取Java对象。若要存储略微复杂的信息，运用Cookie是比拟艰难的。
而Session中能够存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也能够直接保管Java Bean乃至任何Java类，对象等，运用起来十分便当。能够把Session看做是一个Java容器类。

**2 .隐私策略的不同**

Cookie存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正Cookie中的内容。而Session存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。
假如选用Cookie，比较好的方法是，敏感的信息如账号密码等尽量不要写到Cookie中。最好是像Google、Baidu那样将Cookie信息加密，提交到服务器后再进行解密，保证Cookie中的信息只要本人能读得懂。而假如选择Session就省事多了，反正是放在服务器上，Session里任何隐私都能够有效的保护。

**3.有效期上的不同**

使用过Google的人都晓得，假如登录过Google，则Google的登录信息长期有效。用户不用每次访问都重新登录，Google会持久地记载该用户的登录信息。要到达这种效果，运用Cookie会是比较好的选择。只需要设置Cookie的过期时间属性为一个很大很大的数字。

由于Session依赖于名为JSESSIONID的Cookie，而Cookie JSESSIONID的过期时间默许为–1，只需关闭了阅读器该Session就会失效，因而Session不能完成信息永世有效的效果。运用URL地址重写也不能完成。而且假如设置Session的超时时间过长，服务器累计的Session就会越多，越容易招致内存溢出。

**4.服务器压力的不同**

Session是保管在服务器端的，每个用户都会产生一个Session。假如并发访问的用户十分多，会产生十分多的Session，耗费大量的内存。因而像Google、Baidu、Sina这样并发访问量极高的网站，是不太可能运用Session来追踪客户会话的。

而Cookie保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie是很好的选择。关于Google、Baidu、Sina来说，Cookie或许是唯一的选择。

**5 .浏览器支持的不同**

Cookie是需要客户端浏览器支持的。假如客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。关于WAP上的应用，常规的Cookie就派不上用场了。

假如客户端浏览器不支持Cookie，需要运用Session以及URL地址重写。需要注意的是一切的用到Session程序的URL都要进行URL地址重写，否则Session会话跟踪还会失效。关于WAP应用来说，Session+URL地址重写或许是它唯一的选择。

假如客户端支持Cookie，则Cookie既能够设为本浏览器窗口以及子窗口内有效（把过期时间设为–1），也能够设为一切阅读器窗口内有效（把过期时间设为某个大于0的整数）。但Session只能在本阅读器窗口以及其子窗口内有效。假如两个浏览器窗口互不相干，它们将运用两个不同的Session。（IE8下不同窗口Session相干）

**6.跨域支持上的不同**

Cookie支持跨域名访问，例如将domain属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该Cookie。跨域名Cookie如今被普遍用在网络中，例如Google、Baidu、Sina等。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。
仅运用Cookie或者仅运用Session可能完成不了理想的效果。这时应该尝试一下同时运用Cookie与Session。Cookie与Session的搭配运用在实践项目中会完成很多意想不到的效果。

Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。

=======================================================================================================================================================================================================

cookies:是保存在客户端浏览器上的存储空间,通常用来记录浏览器端自己的信息和当前链接的确认信息.
session:会话控制,是在服务器上开辟一段空间用于保留浏览器和服务器交互时的重要数据.
区别:	1.Cookie和Session都是会话技术，Cookie是运行在客户端，Session是运行在服务器端。
   		 2.Cookie有大小限制以及浏览器在存cookie的个数也有限制，Session是没有大小限制和服务器的内存大小有关。
			3.Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。
			4.Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。

## (十四)什么是token，作用

### (1)什么是token?

1. Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。

2. Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

3. 使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。

   ===================================

   token:用户第一次登录，服务器通过数据库校验其UserId和Password合法，则再根据随机数字+userid+当前时间戳 再经过DES加密生成一个token串.

### (2)token主要有两个作用：

①：防止表单重复提交(防止表单重复提交一般还是使用前后端都限制的方式，比如：在前端点击提交之后，将按钮置为灰色，不可再次点击，然后客户端和服务端的token各自独立存储，客户端存储在Cookie或者Form的隐藏域（放在Form隐藏域中的时候，需要每个表单）中，服务端存储在Session（单机系统中可以使用）或者其他缓存系统（分布式系统可以使用）中。)

②：用来作身份验证
3：防止表单重复提交，主要的理念是，客户端初始化的时候，一般就是刚刚进入页面的时候就调用后端代码，后端代码生成一个token,返回给客户端，客户端储存token（可以在前台使用Form表单中使用隐藏域来存储这个Token，也可以使用cookie）,然后就将request(请求)中的token与（session）中的token进行比较：

======================================

作用:1.用户在调用需要登录操作的接口时，无需传递userid和password即可完成操作（因为token代表登录成功）

​		2.服务器控制过期时间，假如一个极端情况，服务器端的token规则泄露，则可以控制用户可以重新登录，获取新的token (3)如何使用Token？

**1.用设备号/设备mac地址作为Token（推荐）**

客户端：客户端在登录的时候获取设备的设备号/mac地址，并将其作为参数传递到服务端。

服务端：服务端接收到该参数后，便用一个变量来接收同时将其作为Token保存在数据库，并将该Token设置到session中，客户端每次请求的时候都要统一拦截，并将客户端传递的token和服务器端session中的token进行对比，如果相同则放行，不同则拒绝。

分析：此刻客户端和服务器端就统一了一个唯一的标识Token，而且保证了每一个设备拥有了一个唯一的会话。该方法的缺点是客户端需要带设备号/mac地址作为参数传递，而且服务器端还需要保存；优点是客户端不需重新登录，只要登录一次以后一直可以使用，至于超时的问题是有服务器这边来处理，如何处理？若服务器的Token超时后，服务器只需将客户端传递的Token向数据库中查询，同时并赋值给变量Token，如此，Token的超时又重新计时。

**2.用session值作为Token**

客户端：客户端只需携带用户名和密码登陆即可。

客户端：客户端接收到用户名和密码后并判断，如果正确了就将本地获取sessionID作为Token返回给客户端，客户端以后只需带上请求数据即可。

分析：这种方式使用的好处是方便，不用存储数据，但是缺点就是当session过期后，客户端必须重新登录才能进行访问数据。

# 三.算法

# 四.正则

# 五.数据库

## (一)MySQL

## (二)MongoDB

## (三)Redis

### **1.Redis是什么?**

(1)是一个完全开源免费的key-value内存数据库

(2)通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets

### **2.Redis数据库**

通常局限点来说,Redis也以消息队列的形式存在,作为内嵌的List存在,满足实时的高并发要求.在使用缓存的时候,把redis当做一个中间存储系统,用来处理高并发的数据库操作.

### **3.Redis数据库优点**

1. 开源的，使用C编写，基于内存且支持持久化
2. 高性能的Key-Value的NoSQL数据库
3. 支持数据类型丰富，字符串strings，散列hashes，列表lists，集合sets，有序集合sorted sets 等
4. 支持多种编程语言（C C++ Python Java PHP ... ）

### **4.Redis数据库缺点**

1. 是数据库容量受到物理内存的限制,不能用左海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上
2. Redis较难支持再现扩容,在集群容量达到上限时在线扩容会变得很复杂.为避免这一问题,运维人员在系统上线时必须确保有足够的空间,这对资源造成很大的浪费

### **5.什么是缓存穿透?如何解决?**

- 查询一个一定不存在的数据，缓存中不存在，则会去数据库中查询，数据库中不存在则不会写入缓存，这导致每次查询都会查询数据库，使缓存失去意义。
- 可以使用空对象，当查询为空时，设置一个特殊的值，和真正合法数据区分开，要有一个较短的过期时间。
- 使用过滤器，先查缓存，缓存存在key则返回；不存在则查询过滤器，过滤器存在则说明不存在值，直接返回空，否则查询数据库。

### **6.什么是缓存雪崩?如何解决?**

- 缓存无法使用导致请求全部到达数据库,导致数据库崩溃
- 缓存高可用,减少缓存不可用时间,数据库限流,服务降级

### **7.什么是缓存击穿?如何解决?**

- 某个key失效时,大量的请求进入,将数据库瞬间压垮.
- 使用锁,确保只有一个线程去查询数据库,手动过期,不设置过期时间,所有key手动过期

## (四)MySQL和redis的区别以及应用场景

MySQL是关系型数据库,主要用于存放持久化数据,将数据存储在硬盘中,读取速度较慢

redis是非关系性数据,也是缓存数据库,即将数据存储在缓存中,缓存的读取熟读块,能狗大大的提高运行效率,但是保存时间有限

应用场景:

mysql:web网站后端数据存储,日志记录系统,数据仓库系统

redis:缓存,排行榜,计算器,分布式会话,分布式锁,消息系统

## (五)什么是索引,索引是不是越多越好

索引是对数据库表中一列或多列的值进行排序的一种机构,索引有助于更快的获取信息

**优点:**

1. 唯一索引可以是索引和信息之间形成一对一的映射的对应关系,增加数据的唯一性特点.
2. 能够提高数据的搜索几检索速度
3. 能够加快表与表之间的连接速度,提高速度的完整性

**缺点:**

1. 数据库建立过程中要花费较多的时间去建立并维护索引,随着总数的增加,花费的时间不断增加
2. 创建索引需要占用一定的物理存储空间
3. 对表中的数据进行修改时,索引还需要进行动态的维护,给数据库的维护速速带来了一定的麻烦

# 六.Django

## (一)框架模式:

​		MVC--model(模型),view(视图),controller(控制器)
​		MTV--model(模型),template(模板),views(视图)
​		1.模型:管理应用程序的状态,数据存取层
​		2.模板:http表现层,如果在页面或者文档中显示
​		3.视图:业务逻辑层,主要是存取模型及调取模板的相关逻辑,既是两者的桥梁	

## (二)安装命令:

​		1.在线安装
​			(1)sudo pip3 install django  默认最新版本
​			(2)sudo pip3 install django[==版本]  安装实指定版本
​			示例:sudo pip3 install django==1.118
​		2.离线安装
​		3.卸载:pip3 uninstall django

## (三)创建流程及命令:

​		1.**创建django: django-admin startproject 项目名**
​		**2.启动服务器: python3 manage.py runserver (端口号)**
​		**3.新建APP: python3 manage.py startapp app名**
​		**4.数据迁移至数据库: python3 manage.py makemigrations**
​				   						 **python3 manage.py migrate**
​		**5.创建超级管理员: python3 manage.py createsuperuser**
​		**6.进入shell指令界面: python3 manage.py shell**

## (四)GET

​		请求指定的页面信息,并返回实体主体(参数通过路由请求)	
​		requset.method=='GET'  通过get方法请求
​		1.request.GET['参数名']
​			必须给个参数
​		2.request.GET.get('参数名','默认值')   
​			参数不写的话 值为默认值
​		3.request.GET.getlist('参数名')
​			参数是列表

## (五)POST

​		向指定资源提交数据进行处理请求(参数通过表单请求)
​		request.method=='POST'  通过post方法请求
​		1.request.POST['参数名']
​			不给值则是空
​		2.request.POST.get('参数名','')
​			挺积累的玩应 一般用上面的方法
​		3.request.POST.getlist('参数名')
​			参数是列表

(六)HttpResponse('str')

​		返回页面显示的数据 必须是字符串str格式

## (七)render(request,'模板名称.html',字典数据)

​		'模板名称.html':返回加载的模板
​		 如有字典或字典数据较多 统一用locals()

## (八)HttpResponseRedirect

​		重定向:当一个逻辑处理完成后，不需要向客户端呈现数据，而是转回到其它页面，如添加成功、修改成功、删除成功后显示数据列表，而数据的列表视图已经开发完成，此时不需要重新编写列表的代码，而是转到这个视图就可以，此时就需要模拟一个用户请求的效果，从一个视图转到另外一个视图，就称为重定向。	

## (九)什么是orm

orm:对象关系映射,是一种为了解决面向对象与关系型数据库存在不匹配现象的技术,只通过类和对象就可以对数据进行操作,不需要写sql语句,另一个作用就是根据设计的类生成数据库的表.

## (十)django的中间件是什么?	

中间件:

是介于request和response处理之间的已到处理过程,用于全局范围内改变django的输入和输出

帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作

- csrf:每次请求通过csrf中间件检查请求中是否有正确token值
- process_request:请求进来,权限验证
- process_view:路由匹配之后,能够得到视图函数
- process_exception:异常时执行
- process_template_responseprocess:模板渲染时执行
- process_response:请求有响应执行

## (十一)django和flask的区别

1. Django:是大而全的方向,它的MTV框架,自带的ORM,admin后台管理,自带sqlite数据库和开发测试用的服务器,给开发者提高了开发效率
2. Flask:是轻量级的矿建,自由,灵活,可扩展性强,核心基于Werking WSGI工具和jinjaz模板引擎
3. Tornado:走的是少而精的方向,性能优越,最出名的是异步非阻塞的设计方式

# 七.ajax

1.判断浏览器是否支持ajax

```js
//file:common.js
function createXhr(){
    var xhr = null;
    //根据不同的浏览器创建不同的异步对象
    if(window.XMLHttpRequest){
      xhr = new XMLHttpRequest();
    }else{
      xhr = new ActiveXObject("Microsoft.XMLHTTP");
    }
    return xhr;
}
```

2.get请求

```html
<script src="/static/common.js"></script>
<script>
function btnShow(){
	//1创建xhr
	var xhr = createXhr()
	//2创建请求
	xhr.open('get','路由地址',true)
	//3设置回调函数
	xhr.onreadystatechange = function(){
		if(xhr.readyState==4 && xhr.status==200){
			//接收服务端相应的数据
			var res = xhr.responseText;
			document.getElementById('show').innerHTML=res
		}	
	}
	//4发送请求
	xhr.send(null)
}
</script>
<body>
	<button onclick='btnShow()'>显示</button>
	<div id='show'></div>
</body>
```

# 八.git

基本命令:

### (1)将githup项目克隆到本地 

git clone git地址

### (2)将本地项目克隆到githup上

git init 

git add .

git commit -m "项目备注或本次上传注释"

git remote add origin git地址

git push -u origin master

输入githup用户名

输入githup密码

完成

# 九.虚拟环境

安装虚拟环境 pip3 install vurtualenv

创建一个文件夹,用于方便管理我们的安装程序  mkdir -p /opt/woftware  

为项目创建一个文件夹  mkdir -p /home/project/my_project			

创建虚拟环境文件名      virtualenv myproject_env	

进入虚拟环境文件夹中执行此命令  source ./bin/activate

进入虚拟环境后 什么东西都要重新安装			

你可以选择使用一个Python解释器

virtualenv -p /usr/bin/python2.7 venv　　　　# -p参数指定Python解释器程序路径

退出虚拟环境指令  deactivate

# 十.云服务


